<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detetor e Analisador de Jogo de Futsal (Simulação)</title>
    <!-- Carrega o Tailwind CSS para um design moderno e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para o placar digital */
        .scoreboard-display {
            font-family: 'Inter', monospace;
            /* Tamanho reduzido para ocupar menos espaço */
            font-size: 4rem; 
            font-weight: 700;
            color: #DC2626; /* primary red */
            text-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
            line-height: 1;
        }
        /* Cor dos botões de controlo */
        .btn-control {
            transition: all 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .btn-control:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        /* Classes dinâmicas de jogadores */
        .player-btn {
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            transition: all 0.15s;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .player-court {
            background-color: #16A34A; /* Green-600 */
            color: white;
            border-color: #16A34A;
        }
        .player-bench {
            background-color: #6B7280; /* Gray-500 */
            color: white;
        }
        /* Cor para o jogador SAINDO (Único) */
        .player-out-select {
            background-color: #EF4444; /* Red-500 */
            color: white;
            animation: pulse-out 1s infinite alternate;
            border-color: #EF4444;
        }
        /* Cor para o jogador ENTRANDO (Único) */
        .player-in-select {
            background-color: #3B82F6; /* Blue-500 */
            color: white;
            animation: pulse-in 1s infinite alternate;
            border-color: #3B82F6;
        }
        .player-btn:hover:not(.player-court):not(.player-out-select):not(.player-in-select) {
            background-color: #4B5563; /* Gray-600 */
        }

        @keyframes pulse-out {
            from { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            to { box-shadow: 0 0 0 6px rgba(239, 68, 68, 0); }
        }
        @keyframes pulse-in {
            from { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            to { box-shadow: 0 0 0 6px rgba(59, 130, 246, 0); }
        }

        /* Estilo para a mensagem de substituição */
        .sub-message {
            background-color: #FEF3C7; /* Yellow-100 */
            color: #92400E; /* Yellow-900 */
            border-left: 4px solid #F59E0B; /* Yellow-500 */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#DC2626', // Vermelho para o placar
                        'secondary': '#1D4ED8', // Azul para os controlos
                        'export': '#059669', // Verde para exportar
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 min-h-screen p-4">
    <div id="app" class="mx-auto bg-white p-8 rounded-xl shadow-2xl w-full max-w-4xl border border-gray-200">
        <h1 class="text-3xl font-bold text-center mb-2 text-gray-800">Simulação de Deteção de Tempo e Substituições</h1>
        <p class="text-center text-gray-600 mb-8">Registo de tempo (MM:SS) e controlo de substituições para o Futsal.</p>

        <!-- SECÇÃO DE CONFIGURAÇÃO DE JOGADORES (1º) -->
        <div id="playerSetupSection" class="p-6 bg-yellow-50 rounded-xl border border-yellow-300 shadow-inner mb-6">
            <h2 class="text-xl font-bold text-yellow-800 mb-4">1. Configuração do Plantel (Edite para cada Jogo)</h2>
            <p class="text-sm text-yellow-700 mb-3">
                Introduza o número e nome de cada jogador, separados por uma vírgula (um jogador por linha). A sua última lista foi guardada.
            </p>
            <textarea id="playerInput" rows="5" class="w-full p-2 border rounded-md font-mono text-sm resize-none">
1,Bebé
2,André Sousa
3,João Matos
4,Nilson
5,Fábio Cecílio
6,Ricardinho
7,Cardinal
8,Pany Varela
9,Tiago Brito
10,Bruno Coelho
11,Miguel Ângelo
12,Vítor Hugo
13,Erick Mendonça
14,Tomás Paçó
15,Afonso Jesus
16,Zicky Té</textarea>
            <button id="loadPlayersBtn" onclick="loadPlayersFromInput()" class="btn-control mt-3 py-2 px-4 rounded-lg text-white font-medium bg-yellow-600 hover:bg-yellow-700">
                Carregar Jogadores e Iniciar Seleção
            </button>
        </div>
        
        <!-- SECÇÃO DE CONFIGURAÇÃO DE TEMPO (2º) -->
        <div id="timeSetupSection" class="p-6 bg-indigo-50 rounded-xl border border-indigo-300 shadow-inner mb-6">
            <h2 class="text-xl font-bold text-indigo-800 mb-4">2. Configuração de Tempo e Direção</h2>
            <p class="text-sm text-indigo-700 mb-3">
                Defina o tempo com que o relógio deve começar e se este conta para baixo (Decrescente) ou para cima (Crescente).
            </p>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                    <label for="initialMinutes" class="block text-sm font-medium text-gray-700 mb-1">Minutos Iniciais</label>
                    <input type="number" id="initialMinutes" value="20" min="0" class="w-full p-2 border rounded-md text-center">
                </div>
                <div>
                    <label for="initialSeconds" class="block text-sm font-medium text-gray-700 mb-1">Segundos Iniciais</label>
                    <input type="number" id="initialSeconds" value="0" min="0" max="59" class="w-full p-2 border rounded-md text-center">
                </div>
                <div>
                    <label for="timeDirection" class="block text-sm font-medium text-gray-700 mb-1">Direção da Contagem</label>
                    <select id="timeDirection" class="w-full p-2 border rounded-md">
                        <option value="down">Decrescente (Padrão Futsal)</option>
                        <option value="up">Crescente (Tempo Corrido)</option>
                    </select>
                </div>
            </div>
            <button id="applyTimeBtn" onclick="updateTimeConfiguration()" class="btn-control mt-4 py-2 px-4 rounded-lg text-white font-medium bg-indigo-600 hover:bg-indigo-700">
                Aplicar Tempo e Resetar Relógio
            </button>
        </div>

        <!-- SECÇÃO DO PLACAR SIMULADO (3º - movido para baixo) -->
        <div id="scoreboardContainer" class="bg-gray-900 sticky top-0 z-10 rounded-lg p-4 mb-6 text-center shadow-inner transition-colors duration-300">
            <h2 class="text-xl font-semibold text-gray-400 mb-2">Relógio de Jogo (Simulação de Fonte de Vídeo)</h2>
            <div id="scoreboardDisplay" class="scoreboard-display">
                20:00
            </div>
        </div>
        
        <!-- SECÇÃO DE JOGADORES E SUBSTITUIÇÕES (4º) -->
        <div class="p-6 bg-white rounded-xl border border-gray-200 shadow-md mb-8">
            <h2 class="text-xl font-bold text-gray-800 mb-4">3. Controlo de Substituições</h2>
            <p id="subStatus" class="p-3 mb-4 rounded-lg text-sm bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 font-medium">
                Por favor, carregue os jogadores no ponto 1.
            </p>
            <div id="playerContainer" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                <!-- Botões dos jogadores serão injetados aqui -->
            </div>
            
            <button id="confirmSubBtn" onclick="confirmSubstitution()" disabled class="btn-control mt-4 py-2 px-4 rounded-lg text-white font-medium bg-secondary hover:bg-blue-600 opacity-50 cursor-not-allowed">
                CONFIRMAR SUBSTITUIÇÃO (Entra / Sai)
            </button>
        </div>


        <!-- CONTROLO DE JOGO, DETEÇÃO E RESET (5º) -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            <!-- Controlo da Simulação de Jogo E Deteção (COMBINADO) -->
            <div class="md:col-span-2 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-lg shadow-md">
                <h3 class="text-lg font-semibold text-blue-800 mb-3">4. Controlo do Jogo (Relógio & Registo)</h3>
                <p class="text-sm text-gray-600 mb-3">
                    Inicia e Pausa o relógio do jogo. O **Registo de Deteção** inicia quando o Relógio é ativado.
                </p>
                <div class="flex space-x-3">
                    <button id="toggleScoreboardBtn" onclick="toggleScoreboardRun()" class="btn-control flex-1 py-3 px-4 rounded-lg text-white font-medium bg-secondary hover:bg-blue-600" disabled>
                        Iniciar Relógio
                    </button>
                    <!-- Novo botão para PARAR TUDO e RESETAR -->
                    <button id="stopResetBtn" onclick="stopAndReset()" class="btn-control py-3 px-4 rounded-lg text-white font-medium bg-gray-500 hover:bg-gray-600" disabled>
                        PARAR E REINICIAR TUDO
                    </button>
                </div>
            </div>

            <!-- Controlo de Exportação (5º) -->
            <div class="p-4 bg-green-50 border-l-4 border-green-500 rounded-lg shadow-md">
                <h3 class="text-lg font-semibold text-green-800 mb-3">5. Exportação de Dados</h3>
                <p class="text-sm text-gray-600 mb-3">Exporta o registo completo (tempo, subs., estado) para formato CSV/Excel.</p>
                <button onclick="exportData()" class="btn-control w-full py-2 px-4 rounded-lg text-white font-medium bg-export hover:bg-green-700">
                    Exportar Registos (CSV para Excel)
                </button>
            </div>
        </div>
        
        <!-- REGISTO DE DADOS (6º) -->
        <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
            <h3 class="text-xl font-semibold text-gray-700 mb-4">Pré-visualização do Registo de Eventos</h3>
            <div id="logPreview" class="bg-white border border-gray-300 p-3 rounded-md h-40 overflow-y-scroll text-sm font-mono text-gray-800">
                Aguardando carregamento dos jogadores...
            </div>
        </div>

    </div>

    <script>
        // --- DADOS E ESTADO GLOBAIS ---
        let initialTotalSeconds = 1200; // Padrão 20:00
        let totalSeconds = 1200; 
        let isCountingUp = false; // Decrescente (false) por padrão
        let scoreboardInterval = null;
        let detectionInterval = null; 
        let isScoreboardRunning = false;
        let isDetectionRunning = false; // Flag para o ciclo de deteção
        
        // Estrutura de Log: { type: 'status' | 'sub' | 'initial_lineup', time: 'MM:SS', status: 'Andar' | 'Parado', detail: {...} }
        let logData = []; 
        
        // Variáveis para guardar a substituição única (jogador/null)
        let selectedPlayerOut = null; 
        let selectedPlayerIn = null; 
        // Cada jogador agora inclui 'totalCourtTimeSeconds' para calcular o tempo total
        let playersData = []; 

        // --- ELEMENTOS DOM ---
        const scoreboardDisplay = document.getElementById('scoreboardDisplay');
        const toggleScoreboardBtn = document.getElementById('toggleScoreboardBtn');
        const stopResetBtn = document.getElementById('stopResetBtn');
        const logPreview = document.getElementById('logPreview');
        const playerContainer = document.getElementById('playerContainer');
        const subStatus = document.getElementById('subStatus');
        const confirmSubBtn = document.getElementById('confirmSubBtn');
        const playerInput = document.getElementById('playerInput');
        const scoreboardContainer = document.getElementById('scoreboardContainer');
        
        // Novos elementos para controlo de tempo
        const initialMinutesInput = document.getElementById('initialMinutes');
        const initialSecondsInput = document.getElementById('initialSeconds');
        const timeDirectionSelect = document.getElementById('timeDirection');


        // --- FUNÇÕES DE CONVERSÃO DE TEMPO ---

        /**
         * Converte MM:SS para segundos totais.
         * @param {string} timeStr - Tempo no formato "MM:SS".
         * @returns {number} Segundos totais.
         */
        function timeToSeconds(timeStr) {
            const [minutes, seconds] = timeStr.split(':').map(Number);
            return minutes * 60 + seconds;
        }

        /**
         * Converte segundos totais para MM:SS.
         * @param {number} totalSeconds - Segundos totais.
         * @returns {string} Tempo no formato "MM:SS".
         */
        function formatSecondsToTime(totalSeconds) {
            const safeSeconds = Math.max(0, totalSeconds);
            const minutes = String(Math.floor(safeSeconds / 60)).padStart(2, '0');
            const secs = String(safeSeconds % 60).padStart(2, '0');
            return `${minutes}:${secs}`;
        }

        function formatTime(seconds) {
            // Usado para o display do placar
            return formatSecondsToTime(seconds);
        }

        function updateScoreboardDisplay() {
            scoreboardDisplay.textContent = formatTime(totalSeconds);
        }

        /**
         * Lógica principal de contagem do relógio.
         */
        function runScoreboard() {
            if (isCountingUp) {
                // Contagem Crescente
                totalSeconds++;
            } else {
                // Contagem Decrescente
                if (totalSeconds > 0) {
                    totalSeconds--;
                } else {
                    // Fim de Jogo (Chegou a 0:00)
                    stopAndReset(true);
                    return; // Sai para não decrementar abaixo de zero
                }
            }
            updateScoreboardDisplay();
        }
        
        /**
         * Atualiza as configurações de tempo e reseta o relógio.
         */
        function updateTimeConfiguration() {
            const minutes = parseInt(initialMinutesInput.value) || 0;
            const seconds = parseInt(initialSecondsInput.value) || 0;
            const direction = timeDirectionSelect.value;
            
            initialTotalSeconds = (minutes * 60) + seconds;
            isCountingUp = direction === 'up';

            // Resetar o relógio para o estado inicial configurado
            if (isCountingUp) {
                // Se for contagem crescente, o relógio começa em 0:00
                totalSeconds = 0;
                toggleScoreboardBtn.textContent = 'Iniciar Relógio (00:00)';
            } else {
                // Se for contagem decrescente, o relógio começa no tempo configurado
                totalSeconds = initialTotalSeconds;
                toggleScoreboardBtn.textContent = `Iniciar Relógio (${formatTime(initialTotalSeconds)})`;
            }

            updateScoreboardDisplay();
            
            // Garantir que os intervalos estão parados e a UI é resetada
            stopContinuousDetection(); 
            clearInterval(scoreboardInterval);
            scoreboardInterval = null;
            isScoreboardRunning = false;
            
            // Reajustar o status da UI
            if (playersData.length > 0) {
                 subStatus.textContent = "Nova configuração de tempo aplicada. Verifique os 5 iniciais (3) e inicie o Relógio (4).";
                 subStatus.classList.remove('bg-red-50', 'bg-yellow-50', 'bg-indigo-50');
                 subStatus.classList.add('bg-green-50', 'border-green-500', 'text-green-800');
            }
            scoreboardContainer.classList.remove('bg-yellow-500');
            scoreboardContainer.classList.add('bg-gray-900');
        }


        // --- FUNÇÕES DE CONTROLO DE DETEÇÃO (Registo Contínuo) ---

        /**
         * Inicia o ciclo de registo que corre continuamente, independentemente do placar.
         */
        function startContinuousDetection() {
            if (isDetectionRunning) return;

            // REGISTO IMEDIATO: Garante que o primeiro registo é feito no momento do clique.
            // DetectAndLogTime será chamado a cada 1s APÓS o primeiro tick.
            
            detectionInterval = setInterval(detectAndLogTime, 1000);
            isDetectionRunning = true;
            console.log("Continuous Detection STARTED.");
        }

        /**
         * Para o ciclo de registo.
         */
        function stopContinuousDetection() {
            if (!isDetectionRunning) return;
            clearInterval(detectionInterval);
            detectionInterval = null;
            isDetectionRunning = false;
            console.log("Continuous Detection STOPPED.");
        }


        /**
         * Lógica que simula a "leitura OCR" (deteção) a cada segundo e regista.
         */
        function detectAndLogTime() {
            const currentTime = scoreboardDisplay.textContent;
            
            // Captura o estado do relógio: Andar (a contar) ou Parado (pausado)
            // Isto será redundante após uma mudança forçada, mas necessário para a granularidade de 1s.
            const status = isScoreboardRunning ? 'Andar' : 'Parado'; 

            // Regista o tempo no logData como um evento 'status' (Tempo/Estado)
            logData.push({ 
                type: 'status', 
                time: currentTime, 
                status: status
            }); 

            // Atualiza a pré-visualização para mostrar o último registo
            updateLogPreview(currentTime, 'time', status);
        }


        // --- FUNÇÕES DE CONTROLO DE JOGO (Placar) ---

        function toggleScoreboardRun() {
            if (isScoreboardRunning) {
                // Lógica de PAUSA
                clearInterval(scoreboardInterval);
                scoreboardInterval = null;
                isScoreboardRunning = false;
                
                const pauseTime = formatTime(totalSeconds);
                
                // *** CORREÇÃO: REGISTO IMEDIATO DE MUDANÇA DE ESTADO para 'Parado' no segundo exato do clique. ***
                logData.push({ 
                    type: 'status', 
                    time: pauseTime, 
                    status: 'Parado'
                }); 
                updateLogPreview(pauseTime, 'time', 'Parado'); // Atualiza UI com o estado imediato

                toggleScoreboardBtn.textContent = `Recomeçar Relógio (Pausado em ${pauseTime})`;
                toggleScoreboardBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                toggleScoreboardBtn.classList.add('bg-secondary', 'hover:bg-blue-600');
                
                subStatus.textContent = "Relógio PAUSADO. O Registo de Deteção continua a correr como 'Parado'. Pode realizar substituições (3).";
                console.log('Scoreboard PAUSED at:', pauseTime); 
                
                // Mudar fundo para amarelo (pausa)
                scoreboardContainer.classList.remove('bg-gray-900');
                scoreboardContainer.classList.add('bg-yellow-500'); 
            } else {
                // Lógica de INÍCIO
                const startTime = formatTime(totalSeconds);
                
                // 1. Regista a escalação inicial no LogData
                const initialCourt = playersData.filter(p => p.court).map(p => ({
                    num: p.number, 
                    name: p.name
                }));

                logData.push({
                    type: 'initial_lineup',
                    time: startTime,
                    status: 'Andar', // Necessário para a lógica de cálculo de tempo total
                    detail: { lineup: initialCourt }
                });
                updateLogPreview(startTime, 'initial_lineup', 'Andar');
                
                // *** NOVO: REGISTO IMEDIATO DE MUDANÇA DE ESTADO para 'Andar' no segundo exato do clique. ***
                logData.push({ 
                    type: 'status', 
                    time: startTime, 
                    status: 'Andar'
                }); 
                updateLogPreview(startTime, 'time', 'Andar'); // Atualiza UI com o estado imediato

                // 2. Inicia o Registo de Deteção se ainda não estiver a correr
                if (!isDetectionRunning) {
                    startContinuousDetection();
                }

                // 3. Inicia o Placar do Jogo
                runScoreboard(); // EXECUTA IMEDIATAMENTE antes do intervalo para feedback instantâneo
                scoreboardInterval = setInterval(runScoreboard, 1000);

                isScoreboardRunning = true;
                
                toggleScoreboardBtn.textContent = 'Pausar Relógio';
                toggleScoreboardBtn.classList.remove('bg-secondary', 'hover:bg-blue-600');
                toggleScoreboardBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                stopResetBtn.disabled = false;
                
                subStatus.textContent = "Relógio ATIVO. O Registo de Deteção está a correr como 'Andar'. Clique no jogador EM CAMPO (verde) para iniciar a substituição.";
                console.log('Scoreboard STARTED at:', startTime); 

                // Mudar fundo para preto (a contar)
                scoreboardContainer.classList.remove('bg-yellow-500');
                scoreboardContainer.classList.add('bg-gray-900');
            }
            
            // Atualiza o estado da UI (para ativar/desativar substituições)
            renderPlayers(); 
        }
        
        /**
         * Para o cronómetro, a deteção e reinicia o tempo e o log.
         * @param {boolean} isEndOfGame - Se TRUE, é uma paragem automática por fim do tempo.
         */
        function stopAndReset(isEndOfGame = false) {
            // 1. Para os intervalos
            clearInterval(scoreboardInterval);
            scoreboardInterval = null;
            isScoreboardRunning = false;
            
            // 2. Para o ciclo de deteção contínua (se estiver a correr)
            stopContinuousDetection(); 
            
            // 3. Reseta o tempo com base na configuração atual
            updateTimeConfiguration(); 

            // 4. Atualiza os botões
            toggleScoreboardBtn.disabled = playersData.length === 0; 
            stopResetBtn.disabled = true;

            // Limpa a seleção de substituição ÚNICA
            selectedPlayerOut = null;
            selectedPlayerIn = null;
            
            // 5. Reseta os totais de tempo para cada jogador
            playersData.forEach(p => p.totalCourtTimeSeconds = 0); 

            // 6. Atualiza o log e o status
            if (isEndOfGame) {
                logPreview.innerHTML = `<div class="text-red-800 font-semibold">FIM DO JOGO: O registo de dados parou. Total de ${logData.length} eventos registados.</div><div class="text-sm text-gray-500">Exporte no ponto 5 para limpar o log.</div>`;
                subStatus.textContent = "FIM DO JOGO. Exportar dados (5) ou carregar novos jogadores (1).";
            } else {
                 logPreview.innerHTML = `<div class="text-indigo-800 font-semibold">Sistema PARADO e REINICIADO.</div><div class="text-sm text-gray-500">O Registo de Deteção está INATIVO. Clique em "Iniciar Relógio" (4) para começar o registo de tempo/estado.</div>`;
                 subStatus.textContent = "Sistema pronto. Selecione 5 jogadores (3) e depois inicie o Relógio (4).";
            }
            
            // Garante que o fundo volta a ser preto (estado inicial/parado)
            scoreboardContainer.classList.remove('bg-yellow-500');
            scoreboardContainer.classList.add('bg-gray-900');

            renderPlayers();
        }


        // --- FUNÇÕES DE CONFIGURAÇÃO DO PLANTEL ---

        function loadPlayersFromInput() {
            const input = playerInput.value.trim();
            const lines = input.split('\n').filter(line => line.trim() !== '');

            if (lines.length === 0) {
                subStatus.textContent = "ERRO: Introduza os dados dos jogadores (Número, Nome) no ponto 1.";
                subStatus.classList.remove('bg-indigo-50', 'bg-green-50', 'bg-yellow-50');
                subStatus.classList.add('bg-red-50', 'border-red-500', 'text-red-800');
                toggleScoreboardBtn.disabled = true; 
                return;
            }

            // Persistência - Salvar o input no localStorage
            localStorage.setItem('futsal_player_list', input);

            // Limpa o estado atual e carrega novos dados
            playersData = [];
            let errorCount = 0;

            lines.forEach(line => {
                const parts = line.split(',').map(part => part.trim());
                const number = parseInt(parts[0]);
                const name = parts[1];

                if (isNaN(number) || number < 1 || !name) {
                    errorCount++;
                    return;
                }

                // Garante que o jogador está em playersData (para manter o estado court)
                const existingPlayer = playersData.find(p => p.number === number);
                if (!existingPlayer) {
                    // Adiciona o novo campo para o total de tempo
                    playersData.push({ number, name, court: false, totalCourtTimeSeconds: 0 });
                } else {
                    existingPlayer.name = name; // Atualiza o nome se o número for repetido
                }
            });

            // Parar e resetar o jogo antes de um novo carregamento
            stopAndReset(); 
            logData = []; 
            selectedPlayerOut = null; 
            selectedPlayerIn = null;
            
            // Habilita o placar se houver jogadores
            toggleScoreboardBtn.disabled = playersData.length === 0;

            if (playersData.length > 0) {
                 // Mensagem inicial ajustada para refletir que o log está à espera
                 logPreview.innerHTML = `<div class="text-indigo-800 font-semibold">Sistema iniciado com ${playersData.length} jogadores.</div><div class="text-sm text-gray-500">O Registo de Deteção está INATIVO. Selecione 5 jogadores (verde) no ponto 3 e depois clique em "Iniciar Relógio" (4) para começar o registo.</div>`;
            }


            if (playersData.length < 5) {
                 subStatus.textContent = `AVISO: Carregou apenas ${playersData.length} jogadores. Precisa de 5 para as Substituições. Agora, selecione os jogadores.`;
                 subStatus.classList.remove('bg-indigo-50', 'bg-green-50', 'bg-red-50');
                 subStatus.classList.add('bg-yellow-50', 'border-yellow-500', 'text-yellow-800');
            } else if (errorCount > 0) {
                subStatus.textContent = `AVISO: ${playersData.length} jogadores carregados. ${errorCount} linha(s) ignorada(s). Selecione os 5 iniciais.`;
                subStatus.classList.remove('bg-indigo-50', 'bg-red-50');
                subStatus.classList.add('bg-yellow-50', 'border-yellow-500', 'text-yellow-800');
            } else {
                subStatus.textContent = `SUCESSO: ${playersData.length} jogadores carregados. Agora, selecione os 5 iniciais no ponto 3.`;
                subStatus.classList.remove('bg-indigo-50', 'bg-red-50', 'bg-yellow-50');
                subStatus.classList.add('bg-green-50', 'border-green-500', 'text-green-800');
            }
            
            // Garantir que todos começam no banco
            playersData.forEach(p => p.court = false);
            renderPlayers(); 
        }

        // --- FUNÇÕES DE SUBSTITUIÇÃO ---

        function renderPlayers() {
            playerContainer.innerHTML = '';
            const courtCount = playersData.filter(p => p.court).length;
            const isInitialSelection = playersData.length > 0 && courtCount < 5;

            playersData.forEach(player => {
                const btn = document.createElement('button');
                btn.className = `player-btn text-sm sm:text-base w-full py-3`;
                btn.textContent = `${player.number} - ${player.name}`;
                btn.onclick = () => handlePlayerClick(player.number);
                
                let playerClass = player.court ? 'player-court' : 'player-bench';

                // Verificar seleção ÚNICA
                const isOut = selectedPlayerOut === player;
                const isIn = selectedPlayerIn === player;

                if (isOut) {
                    playerClass = 'player-out-select';
                } else if (isIn) {
                    playerClass = 'player-in-select';
                }

                btn.classList.add(playerClass);
                playerContainer.appendChild(btn);
            });
            updateSubStatus(courtCount, isInitialSelection);
        }

        function updateSubStatus(courtCount, isInitialSelection) {
            // Contagem e estado único
            const isReady = selectedPlayerOut !== null && selectedPlayerIn !== null && selectedPlayerOut !== selectedPlayerIn;
            
            confirmSubBtn.disabled = !isReady;
            confirmSubBtn.classList.toggle('opacity-50', !isReady);
            confirmSubBtn.classList.toggle('cursor-not-allowed', !isReady);
            confirmSubBtn.classList.toggle('opacity-100', isReady);
            confirmSubBtn.classList.toggle('cursor-pointer', isReady);
            
            subStatus.classList.remove('bg-red-50', 'bg-yellow-50', 'bg-indigo-50', 'bg-green-50');
            subStatus.classList.remove('border-red-500', 'border-yellow-500', 'border-indigo-500', 'border-green-500');

            if (playersData.length === 0) {
                subStatus.textContent = "Por favor, carregue os jogadores no ponto 1 (Configuração do Plantel).";
                subStatus.classList.add('bg-indigo-50', 'border-indigo-500');
            }
            else if (isInitialSelection) {
                subStatus.textContent = `Selecione os 5 jogadores iniciais. (Em campo: ${courtCount}/5)`;
                subStatus.classList.add('bg-indigo-50', 'border-indigo-500');
                
                if (courtCount === 5) {
                    subStatus.textContent = "5 Iniciais selecionados! O Relógio pode ser iniciado no ponto 4. Agora, clique no jogador que SAIR (verde) e no que ENTRAR (cinzento).";
                    subStatus.classList.remove('bg-indigo-50');
                    subStatus.classList.add('bg-green-50', 'border-green-500');
                }
            } else if (selectedPlayerOut || selectedPlayerIn) {
                if (isReady) {
                    subStatus.textContent = `SUBSTITUIÇÃO PRONTA: ${selectedPlayerOut.name} (#${selectedPlayerOut.number}) SAIR >> ${selectedPlayerIn.name} (#${selectedPlayerIn.number}) ENTRAR. Clique em CONFIRMAR.`;
                    subStatus.classList.add('bg-yellow-50', 'border-yellow-500');
                } else if (selectedPlayerOut && !selectedPlayerIn) {
                    subStatus.textContent = `SELECIONADO: ${selectedPlayerOut.name} (#${selectedPlayerOut.number}) para SAIR. Falta selecionar o jogador para ENTRAR (cinzento).`;
                    subStatus.classList.add('bg-red-50', 'border-red-500');
                } else if (!selectedPlayerOut && selectedPlayerIn) {
                    subStatus.textContent = `SELECIONADO: ${selectedPlayerIn.name} (#${selectedPlayerIn.number}) para ENTRAR. Falta selecionar o jogador para SAIR (verde).`;
                    subStatus.classList.add('bg-red-50', 'border-red-500');
                }
            } else if (courtCount === 5) {
                // Caso a seleção inicial já esteja feita (courtCount == 5)
                subStatus.textContent = "Clique no jogador EM CAMPO (verde) para iniciar a substituição.";
                subStatus.classList.add('bg-indigo-50', 'border-indigo-500');
            }
            
            // Estado adicional para indicar o estado do Placar/Registo
            if (isScoreboardRunning) {
                 subStatus.textContent = `Relógio ATIVO (${isCountingUp ? 'Crescente' : 'Decrescente'}). Selecione o jogador para SAIR (verde) e para ENTRAR (cinzento).`;
                 subStatus.classList.add('bg-indigo-50', 'border-indigo-500');
            } 
        }

        function handlePlayerClick(playerNumber) {
            const player = playersData.find(p => p.number === playerNumber);
            const courtCount = playersData.filter(p => p.court).length;
            const isInitialSelection = playersData.length > 0 && courtCount < 5;

            if (isInitialSelection) {
                // Modo de seleção inicial (3. Controlo de Substituições)
                if (player.court) {
                    player.court = false; 
                } else if (courtCount < 5) {
                    player.court = true; 
                }
                renderPlayers();
                return;
            }
            
            // Só permite substituições se houver 5 em campo
            if (courtCount !== 5) return;

            // Modo de substituição ÚNICA
            if (player.court) {
                // Jogador EM CAMPO -> Clicado para SAIR (Out)
                if (selectedPlayerOut === player) {
                    selectedPlayerOut = null; // Desselecionar se clicar no mesmo
                } else if (selectedPlayerOut === null) {
                    selectedPlayerOut = player;
                    // Garante que o jogador que sai não está selecionado para entrar
                    if (selectedPlayerIn === player) selectedPlayerIn = null;
                } else {
                    // Já tem um selecionado, substitui-o
                    selectedPlayerOut = player;
                    if (selectedPlayerIn === player) selectedPlayerIn = null;
                }
            } else {
                // Jogador NO BANCO -> Clicado para ENTRAR (In)
                if (selectedPlayerIn === player) {
                    selectedPlayerIn = null; // Desselecionar se clicar no mesmo
                } else if (selectedPlayerIn === null) {
                    selectedPlayerIn = player;
                    // Garante que o jogador que entra não está selecionado para sair
                    if (selectedPlayerOut === player) selectedPlayerOut = null;
                } else {
                    // Já tem um selecionado, substitui-o
                    selectedPlayerIn = player;
                    if (selectedPlayerOut === player) selectedPlayerOut = null;
                }
            }
            renderPlayers();
        }

        function confirmSubstitution() {
            // Substituição única
            if (!selectedPlayerOut || !selectedPlayerIn || selectedPlayerOut === selectedPlayerIn) {
                console.error("Erro: Substituição incompleta ou inválida.");
                return;
            }
            
            const playerOut = selectedPlayerOut;
            const playerIn = selectedPlayerIn;
            const eventTime = scoreboardDisplay.textContent;
            
            // 1. Atualizar o estado do jogo (playersData)
            playerOut.court = false;
            playerIn.court = true;

            // 2. Criar o registo de evento de substituição
            logData.push({
                type: 'sub', 
                time: eventTime, 
                status: isScoreboardRunning ? 'Andar' : 'Parado', 
                detail: {
                    out_no: playerOut.number,
                    out_name: playerOut.name,
                    in_no: playerIn.number,
                    in_name: playerIn.name
                }
            });
            
            // 3. Atualizar a pré-visualização
            updateLogPreview(
                `SUB: ${playerOut.name} (#${playerOut.number}) >> ${playerIn.name} (#${playerIn.number})`,
                'sub',
                isScoreboardRunning ? 'Andar' : 'Parado'
            );
            
            // 4. Limpar o estado de seleção
            selectedPlayerOut = null;
            selectedPlayerIn = null;
            renderPlayers();
        }
        
        // --- FUNÇÃO DE CÁLCULO DE TEMPO TOTAL EM CAMPO (CORRIGIDA) ---
        
        /**
         * Calcula o tempo total em segundos que cada jogador esteve em campo,
         * contando apenas o tempo em que o relógio estava em estado 'Andar'.
         */
        function calculatePlayerTimeTotals() {
            // Resetar os totais antes de iniciar a contagem
            playersData.forEach(p => p.totalCourtTimeSeconds = 0);
            if (logData.length === 0) return;

            // 1. Determinar o estado inicial (Lineup) e o ponto de partida.
            let currentCourtPlayersNumbers = [];
            let loopStartIndex = 0;

            const initialLineupEvent = logData.find(e => e.type === 'initial_lineup');

            if (initialLineupEvent) {
                // Usar a escalação registada no momento do início do jogo
                currentCourtPlayersNumbers = initialLineupEvent.detail.lineup.map(p => p.num);
                // O loop deve começar no primeiro evento LOGO APÓS a definição da escalação.
                loopStartIndex = logData.indexOf(initialLineupEvent) + 1; 
            } else {
                // Fallback: usar a escalação atual da UI (se o jogo não tiver começado corretamente)
                currentCourtPlayersNumbers = playersData.filter(p => p.court).map(p => p.number);
                console.warn("Nenhum evento de escalação inicial encontrado. Usando estado atual da UI para começar.");
            }
            
            // A lista de jogadores é atualizada no evento logData[i] para o intervalo [i -> i+1].
            
            for (let i = loopStartIndex; i < logData.length - 1; i++) {
                const currentEvent = logData[i];
                const nextEvent = logData[i + 1];

                // --- 1. Cálculo do Intervalo de Tempo (durante o qual o 'currentEvent.status' era válido) ---
                
                // Ignorar o status event se o log estiver desordenado (tempo igual ou a aumentar no decrescente)
                const currentTimeSeconds = timeToSeconds(currentEvent.time);
                const nextTimeSeconds = timeToSeconds(nextEvent.time);
                
                let intervalSeconds = 0;
                if (isCountingUp) {
                    intervalSeconds = nextTimeSeconds - currentTimeSeconds;
                } else {
                    // Contagem Decrescente: Tempo decorrido é o valor de tempo que foi consumido.
                    intervalSeconds = currentTimeSeconds - nextTimeSeconds;
                }

                // Apenas processa se o tempo decorreu (intervalo positivo e razoável)
                if (intervalSeconds > 0 && intervalSeconds < 60) {
                    // --- 2. Adicionar Tempo ---
                    // O tempo é adicionado APENAS se o status do relógio ERA 'Andar' no momento de currentEvent.
                    if (currentEvent.status === 'Andar') {
                        currentCourtPlayersNumbers.forEach(playerNumber => {
                            const player = playersData.find(p => p.number === playerNumber);
                            if (player) {
                                player.totalCourtTimeSeconds += intervalSeconds;
                            }
                        });
                    }
                }

                // --- 3. Atualizar o Estado do Campo (Substituição) ---
                // Se o evento *currentEvent* for uma substituição, o estado do campo muda para o próximo intervalo.
                // A nossa lógica de log já regista a substituição no momento exato, e o tempo é calculado para o intervalo anterior.
                // Aqui, atualizamos a lista de jogadores no campo *para o próximo intervalo*.
                if (currentEvent.type === 'sub') {
                    const d = currentEvent.detail;
                    
                    // Player OUT: Remover
                    const outIndex = currentCourtPlayersNumbers.indexOf(d.out_no);
                    if (outIndex > -1) {
                        currentCourtPlayersNumbers.splice(outIndex, 1);
                    }
                    
                    // Player IN: Adicionar
                    if (!currentCourtPlayersNumbers.includes(d.in_no)) {
                        currentCourtPlayersNumbers.push(d.in_no);
                    }
                }
            }
            // O último intervalo (do penúltimo log até ao último log) não é processado
            // pois não há um 'nextEvent' para definir o fim, o que está correto.
        }


        // --- FUNÇÕES DE LOG E EXPORTAÇÃO ---

        function updateLogPreview(content, type, status = '') {
            const previewEntry = document.createElement('div');
            
            if (type === 'time') {
                // Se for uma mudança de status forçada ('Parado' ou 'Andar')
                const isStatusChange = content === formatTime(totalSeconds) && (status === 'Parado' || status === 'Andar');
                if (isStatusChange) {
                     previewEntry.className = 'text-red-600 font-semibold';
                     previewEntry.textContent = `[ESTADO ATUALIZADO] ${status.toUpperCase()} em ${content}`;
                } else {
                    previewEntry.className = 'text-gray-800';
                    previewEntry.textContent = `[${status.toUpperCase()}] ${content} - Registo de segundo`;
                }
            } else if (type === 'sub') {
                previewEntry.className = 'sub-message p-1 my-1 rounded';
                previewEntry.textContent = `[${status.toUpperCase()}] Substituição: ${content}`;
            } else if (type === 'initial_lineup') {
                 previewEntry.className = 'sub-message p-1 my-1 rounded bg-green-100 border-green-500 text-green-800';
                 previewEntry.textContent = `[INÍCIO] Escalação inicial registada em ${content}`;
            }

            logPreview.prepend(previewEntry);
            
            while (logPreview.children.length > 10) {
                logPreview.removeChild(logPreview.lastChild);
            }
        }

        /**
         * Exporta os dados registados para um ficheiro CSV.
         * Corrigido para usar PONTO E VÍRGULA (;) como delimitador para compatibilidade com Excel europeu/português
         * e para formatar o log de eventos (Secção 3) para mostrar o estado apenas em caso de alteração,
         * omitindo o estado do relógio nas linhas de substituição.
         */
        function exportData() {
            if (logData.length === 0) {
                subStatus.textContent = "Não há dados registados para exportar. Inicie o jogo (4) primeiro.";
                return;
            }

            // --- 0. CALCULAR TOTAIS DE TEMPO ---
            calculatePlayerTimeTotals(); 

            // Alterado para ponto e vírgula (;) para melhor compatibilidade com Excel em regiões como Portugal.
            const delimiter = ';'; 
            // Adiciona o BOM (Byte Order Mark) para compatibilidade com caracteres especiais no Excel
            const bom = "\uFEFF"; 
            
            const finalContentArray = [];

            // --------------------------------------------------------
            // SECÇÃO 1: ESCALAÇÃO INICIAL
            // --------------------------------------------------------
            finalContentArray.push("--------------------- SECÇÃO 1: ESCALAÇÃO INICIAL ---------------------");
            finalContentArray.push(["Número", "Nome", "Status Inicial (No Início do Jogo)"].join(delimiter));
            
            const initialLineupEvent = logData.find(e => e.type === 'initial_lineup');
            const initialLineupNumbers = initialLineupEvent ? initialLineupEvent.detail.lineup.map(p => p.num) : playersData.filter(p => p.court).map(p => p.number);
            
            const lineupLines = playersData.map((player) => {
                const isInitial = initialLineupNumbers.includes(player.number);
                
                return [
                    player.number, 
                    player.name, 
                    isInitial ? "Titular" : "Banco"
                ].join(delimiter);
            });
            finalContentArray.push(...lineupLines);
            finalContentArray.push(""); // Linha de separação


            // --------------------------------------------------------
            // SECÇÃO 2: RESUMO DE TEMPO POR JOGADOR (NOVO)
            // --------------------------------------------------------
            finalContentArray.push("------------------- SECÇÃO 2: RESUMO DE TEMPO TOTAL -------------------");
            finalContentArray.push(["Número", "Nome do Jogador", "Tempo Total em Campo (MM:SS)", "Tempo Total em Campo (Segundos)"].join(delimiter));

            // Ordena por tempo total (decrescente)
            const sortedPlayersByTime = playersData.sort((a, b) => b.totalCourtTimeSeconds - a.totalCourtTimeSeconds);

            const timeSummaryLines = sortedPlayersByTime.map(player => {
                const timeStr = formatSecondsToTime(player.totalCourtTimeSeconds);
                return [
                    player.number,
                    player.name,
                    timeStr,
                    player.totalCourtTimeSeconds 
                ].join(delimiter);
            });
            finalContentArray.push(...timeSummaryLines);
            finalContentArray.push(""); // Linha de separação

            // --------------------------------------------------------
            // SECÇÃO 3: REGISTO DE EVENTOS (LOG)
            // --------------------------------------------------------
            finalContentArray.push("------------------ SECÇÃO 3: REGISTO DE EVENTOS (LOG) -----------------");
            finalContentArray.push(["Tempo (MM:SS)", "Estado do Relógio", "Tipo de Evento", "Num Sai", "Nome Sai", "Num Entra", "Nome Entra"].join(delimiter));

            let previousClockStatus = null; // Para controlar a repetição do estado

            // Filtra o log para remover a linha de escalação inicial (já tratada na Secção 1)
            const logLines = logData.filter(e => e.type !== 'initial_lineup').map(entry => {
                
                const currentClockStatus = entry.status || 'N/A';
                
                let statusCol = "";
                let typeCol = "";
                let outNum = "";
                let outName = "";
                let inNum = "";
                let inName = "";

                if (entry.type === 'status') {
                    // --- Lógica de Estado (Andar/Parado): Só preenche se houver MUDANÇA ---
                    
                    if (currentClockStatus !== previousClockStatus) {
                        statusCol = currentClockStatus; // Exibir o novo estado
                        previousClockStatus = currentClockStatus; // Guardar o novo estado
                    } else {
                        // Estado igual ao anterior, célula em branco (para otimizar a visualização)
                        statusCol = ""; 
                    }
                    
                    // Coluna C: Tipo de Evento fica vazio para eventos de status
                    typeCol = ""; 

                } else if (entry.type === 'sub') {
                    // --- Lógica de Substituição ---
                    const d = entry.detail;
                    
                    // Coluna C: Tipo de Evento = "Substituição" (como pedido)
                    typeCol = "Substituição"; 
                    
                    // Coluna B: Estado do Relógio (REGRA: Fica em branco para Substituições)
                    statusCol = ""; 
                    
                    // Manter: Forçar a atualização do estado anterior para que a próxima linha saiba o estado REAL
                    previousClockStatus = currentClockStatus; 

                    // Colunas de detalhes
                    outNum = d.out_no;
                    outName = d.out_name;
                    inNum = d.in_no;
                    inName = d.in_name;
                }
                
                // Combina tudo usando o delimitador
                return [entry.time, statusCol, typeCol, outNum, outName, inNum, inName].join(delimiter);
            }).filter(line => line.trim() !== delimiter.repeat(6)); // Remove linhas que sejam apenas o delimitador repetido

            finalContentArray.push(...logLines);

            const fileContent = bom + finalContentArray.join('\n');
            const blob = new Blob([fileContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'registo_jogo_futsal_export_com_totais.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // 5. Limpa o log após a exportação e reseta o estado.
            logData = [];
            stopAndReset(); 
            
            // Mensagem de sucesso
            subStatus.textContent = `Dados exportados com sucesso! Ficheiro: registo_jogo_futsal_export_com_totais.csv (Separador: Ponto e Vírgula ';'). O log foi reiniciado.`;
            subStatus.classList.remove('bg-indigo-50', 'bg-red-50', 'bg-yellow-50');
            subStatus.classList.add('bg-green-50', 'border-green-500', 'text-green-800');
        }

        // --- INICIALIZAÇÃO ---
        document.addEventListener('DOMContentLoaded', () => {
            // Inicia com a configuração padrão (20:00 Decrescente)
            updateTimeConfiguration(); 
            
            // Persistência - Carregar lista de jogadores guardada
            const savedList = localStorage.getItem('futsal_player_list');
            if (savedList) {
                playerInput.value = savedList;
            }
            
            // Carrega os dados (guardados ou de exemplo) automaticamente
            loadPlayersFromInput();
            
            // Adicionar listeners para garantir que a UI se atualiza ao editar o tempo
            initialMinutesInput.addEventListener('change', updateTimeConfiguration);
            initialSecondsInput.addEventListener('change', updateTimeConfiguration);
            timeDirectionSelect.addEventListener('change', updateTimeConfiguration);
        });

    </script>
</body>
</html>