<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volume de Jogo</title>
    <!-- Carrega o Tailwind CSS para um design moderno e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para o placar digital */
        .scoreboard-display {
            font-family: 'Inter', monospace;
            font-size: 5.5rem; /* Maior para destaque em tablet */
            font-weight: 800;
            color: #EF4444; /* Red-500 */
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
            line-height: 1;
        }
        /* Estilo base para todos os bot√µes de controlo */
        .btn-base {
            transition: all 0.2s;
            border-radius: 12px; /* Cantos mais arredondados */
            font-weight: 600;
            padding: 12px 24px; 
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.1);
        }
        .btn-base:hover {
            opacity: 0.95;
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.15);
        }

        /* Estilos para o bot√£o principal de A√ß√£o (Iniciar/Pausar) - REMOVIDO w-full daqui para permitir max-w-sm e mx-auto no HTML */
        .btn-action-main {
            @apply btn-base text-white text-3xl block; 
            padding: 24px 24px; /* Aumento do padding para o bot√£o principal para ser grande */
        }
        
        /* Estilos para os bot√µes de Configura√ß√£o (Load/Apply) */
        .btn-config {
             @apply btn-base text-white w-full py-3 text-lg;
             padding: 12px 24px; /* Padding padr√£o para bot√µes menores */
        }

        /* Estilos para os bot√µes de Jogadores */
        .player-btn {
            padding: 12px 8px; /* Maior √°rea de toque */
            border-radius: 10px;
            font-weight: 700;
            text-align: center;
            transition: all 0.15s;
            cursor: pointer;
            border: 3px solid transparent; /* Borda mais grossa para feedback de sele√ß√£o */
            font-size: 0.95rem; 
        }
        /* Jogadores em Campo (Verde) */
        .player-court {
            background-color: #10B981; /* Emerald-500 (Clean Green) */
            color: white;
            border-color: #059669; 
        }
        /* Jogadores no Banco (Cinza) */
        .player-bench {
            background-color: #9CA3AF; /* Gray-400 */
            color: #374151;
            border-color: #6B7280;
        }
        /* Cor para o jogador SAINDO */
        .player-out-select {
            background-color: #F87171; /* Red-400 */
            color: white;
            animation: pulse-out 1s infinite alternate;
            border-color: #DC2626; /* Borda Vermelha Forte */
        }
        /* Cor para o jogador ENTRANDO */
        .player-in-select {
            background-color: #60A5FA; /* Blue-400 */
            color: white;
            animation: pulse-in 1s infinite alternate;
            border-color: #2563EB; /* Borda Azul Forte */
        }
        /* Anima√ß√µes de pulso para feedback visual claro */
        @keyframes pulse-out {
            from { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.5); }
            to { box-shadow: 0 0 0 8px rgba(248, 113, 113, 0); }
        }
        @keyframes pulse-in {
            from { box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.5); }
            to { box-shadow: 0 0 0 8px rgba(96, 165, 250, 0); }
        }

        /* Estilo para a mensagem de status/substitui√ß√£o */
        .status-message {
            padding: 16px;
            border-left: 6px solid; /* Borda mais grossa */
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 20px;
        }

        /* Estilo para fixar o Placar no topo */
        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 10; /* Garante que fica por cima de outros elementos */
            width: 100%; /* Garante a largura total */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-red': '#DC2626', // Vermelho do placar
                        'control-blue': '#3B82F6', // Azul dos controlos
                        'export-green': '#059669', // Verde da exporta√ß√£o
                        'neutral-light': '#F9FAFB', // Fundo dos cards
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">
    <!-- Removida a padding do div#app para controlar o padding de forma mais granular nos sub-elementos -->
    <div id="app" class="mx-auto bg-white rounded-3xl shadow-2xl w-full max-w-6xl border border-gray-100">
        
        <div class="px-6 sm:px-10 pt-6">
            <h1 class="text-3xl font-extrabold text-center mb-1 text-gray-900">Volume de Jogo</h1>
        </div>

        <!-- PLACAR FIXO (STICKY HEADER) -->
<div id="stickyHeader" class="sticky-header bg-white pb-6 pt-2 rounded-b-2xl shadow-xl border-b border-gray-200">
    
    <div class="px-6 sm:px-10">
        
        <div class="flex justify-end items-center mb-1 pt-2"> 
            <button onclick="toggleClockLock()" class="text-gray-500 hover:text-gray-700 transition duration-150 p-1.5 rounded-full">
                <span id="lockIcon" class="text-xl">üîì</span> 
            </button>
        </div>
        <div id="scoreboardContainer" class="bg-gray-900 rounded-2xl p-3 text-center shadow-lg transition-colors duration-300 border-2 border-gray-800 mb-2">
            <h3 class="text-lg font-semibold text-gray-400 mb-1">Rel√≥gio de Jogo (MM:SS)</h3>
            <div id="scoreboardDisplay" class="scoreboard-display">
                20:00
            </div>
        </div>

        <button id="toggleScoreboardBtn" onclick="toggleScoreboardRun()" 
            class="btn-action-main bg-control-blue hover:bg-blue-600 w-full mx-auto block" 
            disabled>
            Iniciar Rel√≥gio
        </button>
    </div>
</div>
        
        <!-- MAIN CONTENT WRAPPER -->
        <div class="p-6 sm:p-10 pt-4"> <!-- Ajustei o padding-top ligeiramente -->
            
            <!-- SEC√á√ïES DE CONFIGURA√á√ÉO E SUBSTITUI√á√ÉO (Cont√≠nuas) -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

                <!-- COLUNA ESQUERDA: CONFIGURA√á√ÉO -->
                <div class="lg:col-span-1 space-y-6">

                    <!-- 1. CONFIGURA√á√ÉO DO PLANTEL -->
                    <div class="p-6 bg-neutral-light rounded-2xl border border-gray-200 shadow-md">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">1. Plantel (Lista)</h2>
                        <textarea id="playerInput" rows="7" class="w-full p-3 border border-gray-300 rounded-lg font-mono text-sm resize-none focus:ring-2 focus:ring-blue-400">
1,Edu
2,Andr√© Coelho
3,Tom√°s Pa√ß√≥
4,Afonso Jesus
5,R√∫ben G√≥is
6,Kutchy
7,Diogo Santos
8,Erick
9,Bruno Maior
10,Bruno Coelho
11,Pany
12,Andr√© Coelho
13,Tiago Brito
14,Carlinhos
16,Bernardo Pa√ßo
15,Outro</textarea>
                        <button id="loadPlayersBtn" onclick="loadPlayersFromInput()" class="btn-config mt-4 w-full text-white bg-green-600 hover:bg-green-700">
                            Carregar Jogadores
                        </button>
                    </div>

                    <!-- 2. CONFIGURA√á√ÉO DE TEMPO -->
                    <div class="p-6 bg-neutral-light rounded-2xl border border-gray-200 shadow-md">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">2. Configura√ß√£o de Tempo</h2>
                        
                        <!-- Presets de Tempo -->
                        <div class="mb-4">
                            <label for="timePreset" class="block text-sm font-medium text-gray-700 mb-1">Presets de Jogo</label>
                            <select id="timePreset" onchange="applyPreset()" class="w-full p-3 border border-gray-300 rounded-lg">
                                <option value="futsal">Futsal Padr√£o (Decrescente 20:00)</option>
                                <option value="corrido">Tempo Corrido (Crescente 00:00)</option>
                            </select>
                        </div>

                        <div class="space-y-4">
                            <div>
                                <label for="timeDirection" class="block text-sm font-medium text-gray-700 mb-1">Dire√ß√£o da Contagem</label>
                                <select id="timeDirection" class="w-full p-3 border border-gray-300 rounded-lg">
                                    <option value="down">Decrescente (Padr√£o Futsal)</option>
                                    <option value="up">Crescente (Tempo Corrido)</option>
                                </select>
                            </div>
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <!-- TEXTO (M√°x: 145) REMOVIDO PARA ALINHAMENTO -->
                                    <label for="initialMinutes" class="block text-sm font-medium text-gray-700 mb-1">Minutos Iniciais</label>
                                    <input type="number" id="initialMinutes" value="20" min="0" max="145" class="w-full p-3 border border-gray-300 rounded-lg text-center">
                                </div>
                                <div>
                                    <label for="initialSeconds" class="block text-sm font-medium text-gray-700 mb-1">Segundos Iniciais</label>
                                    <input type="number" id="initialSeconds" value="0" min="0" max="59" class="w-full p-3 border border-gray-300 rounded-lg text-center">
                                </div>
                            </div>
                        </div>
                        <button id="applyTimeBtn" onclick="updateTimeConfiguration()" class="btn-config mt-4 w-full text-white bg-indigo-600 hover:bg-indigo-700">
                            Aplicar Tempo e Resetar
                        </button>
                    </div>
                </div>

                <!-- COLUNA DIREITA: SUBSTITUI√á√ïES (Priorit√°ria) -->
                <div class="lg:col-span-2 space-y-6">
                    <!-- 3. CONTROLO DE SUBSTITUI√á√ïES -->
                    <div class="p-6 bg-neutral-light rounded-2xl border border-gray-200 shadow-md">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">3. Controlo de Substitui√ß√µes e 5 Iniciais</h2>
                        
                        <div id="subStatus" class="status-message bg-indigo-50 border-indigo-500 text-indigo-800">
                            Por favor, carregue os jogadores no ponto 1.
                        </div>
                        
                        <div id="playerContainer" class="grid grid-cols-4 sm:grid-cols-6 gap-3 mb-6">
                            <!-- Bot√µes dos jogadores ser√£o injetados aqui -->
                        </div>
                        
                        <!-- BOT√ÉO DE SUBSTITUI√á√ÉO -->
                        <button id="confirmSubBtn" onclick="confirmSubstitution()" disabled class="btn-base w-full py-4 text-white bg-primary-red hover:bg-red-600 opacity-50 cursor-not-allowed text-lg">
                            CONFIRMAR SUBSTITUI√á√ÉO
                        </button>

                    </div>
                </div>
            </div>
            
            <!-- SEC√á√ÉO DE LOGS E EXPORTA√á√ÉO (No Fundo) -->
            <div class="mt-8">
                <div class="p-6 bg-neutral-light rounded-2xl border border-gray-200 shadow-md">
                    <h2 class="text-xl font-bold text-gray-800 mb-4">4. Registo de Eventos (Log) e Exporta√ß√£o</h2>
                    
                    <div id="logPreview" class="bg-white border border-gray-300 p-4 rounded-lg h-48 overflow-y-scroll text-sm font-mono text-gray-700 mb-4">
                        Aguardando carregamento dos jogadores...
                    </div>
                    
                    <!-- Bot√µes de Controlo e Exporta√ß√£o JUNTOS -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <button id="stopResetBtn" onclick="stopAndReset()" class="btn-base bg-gray-500 hover:bg-gray-600 text-white" disabled>
                            PARAR E REINICIAR TUDO
                        </button>
                        <button onclick="exportData()" class="btn-base text-white bg-export-green hover:bg-green-700">
                            Exportar Registos (CSV para Excel)
                        </button>
                    </div>
                </div>
            </div>

        </div> <!-- Fim do Main Content Wrapper -->
    </div>

    <script>
        // --- DADOS E ESTADO GLOBAIS ---
        let initialTotalSeconds = 1200; // Padr√£o 20:00
        let totalSeconds = 1200; 
        let isCountingUp = false; // Decrescente (false) por padr√£o
        let scoreboardInterval = null;
        let detectionInterval = null; 
        let isScoreboardRunning = false;
        let isDetectionRunning = false; // Flag para o ciclo de dete√ß√£o
        
        // Estrutura de Log: { type: 'status' | 'sub' | 'initial_lineup', time: 'MM:SS', status: 'Andar' | 'Parado', detail: {...} }
        let logData = []; 
        
        // Vari√°veis para guardar a substitui√ß√£o √∫nica (jogador/null)
        let selectedPlayerOut = null; 
        let selectedPlayerIn = null; 
        // Cada jogador agora inclui 'totalCourtTimeSeconds' para calcular o tempo total
        let playersData = []; 

        // --- ELEMENTOS DOM ---
        const scoreboardDisplay = document.getElementById('scoreboardDisplay');
        const toggleScoreboardBtn = document.getElementById('toggleScoreboardBtn');
        const stopResetBtn = document.getElementById('stopResetBtn');
        const logPreview = document.getElementById('logPreview');
        const playerContainer = document.getElementById('playerContainer');
        const subStatus = document.getElementById('subStatus');
        const confirmSubBtn = document.getElementById('confirmSubBtn');
        const playerInput = document.getElementById('playerInput');
        const scoreboardContainer = document.getElementById('scoreboardContainer');
        
        // Novos elementos para controlo de tempo
        const initialMinutesInput = document.getElementById('initialMinutes');
        const initialSecondsInput = document.getElementById('initialSeconds');
        const timeDirectionSelect = document.getElementById('timeDirection');
        const timePresetSelect = document.getElementById('timePreset'); 


        // --- FUN√á√ïES DE CONVERS√ÉO DE TEMPO ---

        /**
         * Converte MM:SS para segundos totais.
         * @param {string} timeStr - Tempo no formato "MM:SS".
         * @returns {number} Segundos totais.
         */
        function timeToSeconds(timeStr) {
            const [minutes, seconds] = timeStr.split(':').map(Number);
            return minutes * 60 + seconds;
        }

        /**
         * Converte segundos totais para MM:SS.
         * @param {number} totalSeconds - Segundos totais.
         * @returns {string} Tempo no formato "MM:SS".
         */
        function formatSecondsToTime(totalSeconds) {
            const safeSeconds = Math.max(0, totalSeconds);
            const minutes = String(Math.floor(safeSeconds / 60)).padStart(2, '0');
            const remainingSeconds = String(safeSeconds % 60).padStart(2, '0');
            return `${minutes}:${remainingSeconds}`;
        }

        function formatTime(seconds) {
            // Usado para o display do placar
            return formatSecondsToTime(seconds);
        }

        function updateScoreboardDisplay() {
            scoreboardDisplay.textContent = formatTime(totalSeconds);
        }
        
        // --- FUN√á√ÉO PARA APLICAR PRESET ---
        function applyPreset() {
            const preset = timePresetSelect.value;
            
            if (preset === 'futsal') {
                initialMinutesInput.value = 20;
                initialSecondsInput.value = 0;
                timeDirectionSelect.value = 'down';
                initialMinutesInput.max = 60; // Max razo√°vel para minutos de jogo
            } else if (preset === 'corrido') {
                initialMinutesInput.value = 0; // Inicia em 0:00 por padr√£o, mas pode ser alterado
                initialSecondsInput.value = 0;
                timeDirectionSelect.value = 'up';
                initialMinutesInput.max = 145; // Max 145 minutos, conforme pedido
            }
            // Chama a fun√ß√£o principal de configura√ß√£o para aplicar e resetar
            updateTimeConfiguration(); 
        }


        /**
         * L√≥gica principal de contagem do rel√≥gio.
         */
        function runScoreboard() {
            if (isCountingUp) {
                // Contagem Crescente
                totalSeconds++;
            } else {
                // Contagem Decrescente
                if (totalSeconds > 0) {
                    totalSeconds--;
                } else {
                    // Fim de Jogo (Chegou a 0:00)
                    stopAndReset(true);
                    return; // Sai para n√£o decrementar abaixo de zero
                }
            }
            updateScoreboardDisplay();
        }
        
        /**
         * Atualiza as configura√ß√µes de tempo e reseta o rel√≥gio.
         */
        function updateTimeConfiguration() {
            let minutes = parseInt(initialMinutesInput.value) || 0;
            const seconds = parseInt(initialSecondsInput.value) || 0;
            const direction = timeDirectionSelect.value;
            
            // Limitador para minutos: 145 min (8700 segundos)
            const maxMinutes = parseInt(initialMinutesInput.max) || 145;
            minutes = Math.min(minutes, maxMinutes);
            initialMinutesInput.value = minutes; // Atualiza o campo com o valor limitado

            initialTotalSeconds = (minutes * 60) + seconds;
            isCountingUp = direction === 'up';

            // Resetar o rel√≥gio para o estado inicial configurado:
            // O rel√≥gio deve come√ßar no tempo configurado, independentemente da dire√ß√£o.
            totalSeconds = initialTotalSeconds;

            toggleScoreboardBtn.textContent = isScoreboardRunning 
                ? 'Pausar Rel√≥gio' 
                : `Iniciar Rel√≥gio (${formatTime(totalSeconds)})`;


            updateScoreboardDisplay();
            
            // Garantir que os intervalos est√£o parados e a UI √© resetada
            stopContinuousDetection(); 
            clearInterval(scoreboardInterval);
            scoreboardInterval = null;
            isScoreboardRunning = false;
            
            // Reajustar o status da UI
            if (playersData.length > 0) {
                 subStatus.textContent = "Nova configura√ß√£o de tempo aplicada. Verifique os 5 iniciais (3) e inicie o Rel√≥gio.";
                 subStatus.className = 'status-message bg-green-50 border-green-500 text-green-800';
            }
            scoreboardContainer.classList.remove('bg-amber-500');
            scoreboardContainer.classList.add('bg-gray-900');
        }


        // --- FUN√á√ïES DE CONTROLO DE DETE√á√ÉO (Registo Cont√≠nuo) ---

        /**
         * Inicia o ciclo de registo que corre continuamente, independentemente do placar.
         */
        function startContinuousDetection() {
            if (isDetectionRunning) return;
            
            detectionInterval = setInterval(detectAndLogTime, 1000);
            isDetectionRunning = true;
            console.log("Continuous Detection STARTED.");
        }

        /**
         * Para o ciclo de registo.
         */
        function stopContinuousDetection() {
            if (!isDetectionRunning) return;
            clearInterval(detectionInterval);
            detectionInterval = null;
            isDetectionRunning = false;
            console.log("Continuous Detection STOPPED.");
        }


        /**
         * L√≥gica que simula a "leitura OCR" (dete√ß√£o) a cada segundo e regista.
         */
        function detectAndLogTime() {
            const currentTime = scoreboardDisplay.textContent;
            
            // Captura o estado do rel√≥gio: Andar (a contar) ou Parado (pausado)
            const status = isScoreboardRunning ? 'Andar' : 'Parado'; 

            // Regista o tempo no logData como um evento 'status' (Tempo/Estado)
            logData.push({ 
                type: 'status', 
                time: currentTime, 
                status: status
            }); 

            // Atualiza a pr√©-visualiza√ß√£o para mostrar o √∫ltimo registo
            updateLogPreview(currentTime, 'time', status);
        }


        // --- FUN√á√ïES DE CONTROLO DE JOGO (Placar) ---

        function toggleScoreboardRun() {
            if (isScoreboardRunning) {
                // L√≥gica de PAUSA
                clearInterval(scoreboardInterval);
                scoreboardInterval = null;
                isScoreboardRunning = false;
                
                const pauseTime = formatTime(totalSeconds);
                
                // REGISTO IMEDIATO DE MUDAN√áA DE ESTADO para 'Parado' no segundo exato do clique.
                logData.push({ 
                    type: 'status', 
                    time: pauseTime, 
                    status: 'Parado'
                }); 
                updateLogPreview(pauseTime, 'time', 'Parado'); // Atualiza UI com o estado imediato

                toggleScoreboardBtn.textContent = `Recome√ßar Rel√≥gio (Pausado em ${pauseTime})`;
                toggleScoreboardBtn.classList.remove('bg-amber-500', 'hover:bg-amber-600');
                toggleScoreboardBtn.classList.add('bg-control-blue', 'hover:bg-blue-600');
                
                subStatus.textContent = "Rel√≥gio PAUSADO. O Registo de Dete√ß√£o continua a correr como 'Parado'. Pode realizar substitui√ß√µes (3).";
                subStatus.className = 'status-message bg-yellow-50 border-yellow-500 text-yellow-800';
                console.log('Scoreboard PAUSED at:', pauseTime); 
                
                // Mudar fundo para amarelo (pausa)
                scoreboardContainer.classList.remove('bg-gray-900');
                scoreboardContainer.classList.add('bg-amber-500'); 
            } else {
                // L√≥gica de IN√çCIO
                const startTime = formatTime(totalSeconds);
                
                // 1. Regista a escala√ß√£o inicial no LogData
                const initialCourt = playersData.filter(p => p.court).map(p => ({
                    num: p.number, 
                    name: p.name
                }));

                // Adiciona o evento de escala√ß√£o INICIAL APENAS se n√£o houver j√° um evento 'initial_lineup'
                if (!logData.some(e => e.type === 'initial_lineup')) {
                    logData.push({
                        type: 'initial_lineup',
                        time: startTime,
                        status: 'Andar', // Necess√°rio para a l√≥gica de c√°lculo de tempo total
                        detail: { lineup: initialCourt }
                    });
                    updateLogPreview(startTime, 'initial_lineup', 'Andar');
                }
                
                // NOVO: REGISTO IMEDIATO DE MUDAN√áA DE ESTADO para 'Andar' no segundo exato do clique.
                logData.push({ 
                    type: 'status', 
                    time: startTime, 
                    status: 'Andar'
                }); 
                updateLogPreview(startTime, 'time', 'Andar'); // Atualiza UI com o estado imediato

                // 2. Inicia o Registo de Dete√ß√£o se ainda n√£o estiver a correr
                if (!isDetectionRunning) {
                    startContinuousDetection();
                }

                // 3. Inicia o Placar do Jogo
                runScoreboard(); // EXECUTA IMEDIATAMENTE antes do intervalo para feedback instant√¢neo
                scoreboardInterval = setInterval(runScoreboard, 1000);

                isScoreboardRunning = true;
                
                toggleScoreboardBtn.textContent = 'Pausar Rel√≥gio';
                toggleScoreboardBtn.classList.remove('bg-control-blue', 'hover:bg-blue-600');
                toggleScoreboardBtn.classList.add('bg-amber-500', 'hover:bg-amber-600');
                stopResetBtn.disabled = false;
                
                subStatus.textContent = "Rel√≥gio ATIVO. O Registo de Dete√ß√£o est√° a correr como 'Andar'. Clique no jogador EM CAMPO (verde) para iniciar a substitui√ß√£o (3).";
                subStatus.className = 'status-message bg-indigo-50 border-indigo-500 text-indigo-800';
                console.log('Scoreboard STARTED at:', startTime); 

                // Mudar fundo para preto (a contar)
                scoreboardContainer.classList.remove('bg-amber-500');
                scoreboardContainer.classList.add('bg-gray-900');
            }
            
            // Atualiza o estado da UI (para ativar/desativar substitui√ß√µes)
            renderPlayers(); 
        }
        
        /**
         * Para o cron√≥metro, a dete√ß√£o e reinicia o tempo e o log.
         * @param {boolean} isEndOfGame - Se TRUE, √© uma paragem autom√°tica por fim do tempo.
         */
        function stopAndReset(isEndOfGame = false) {
            // 1. Para os intervalos
            clearInterval(scoreboardInterval);
            scoreboardInterval = null;
            isScoreboardRunning = false;
            
            // 2. Para o ciclo de dete√ß√£o cont√≠nua (se estiver a correr)
            stopContinuousDetection(); 
            
            // 3. Reseta o tempo com base na configura√ß√£o atual
            updateTimeConfiguration(); 

            // 4. Atualiza os bot√µes
            toggleScoreboardBtn.disabled = playersData.length === 0; 
            stopResetBtn.disabled = true;

            // Limpa a sele√ß√£o de substitui√ß√£o √öNICA
            selectedPlayerOut = null;
            selectedPlayerIn = null;
            
            // 5. Reseta os totais de tempo para cada jogador
            playersData.forEach(p => p.totalCourtTimeSeconds = 0); 

            // 6. Atualiza o log e o status
            if (isEndOfGame) {
                logPreview.innerHTML = `<div class="text-red-700 font-semibold">FIM DO JOGO: O registo de dados parou. Total de ${logData.length} eventos registados.</div><div class="text-sm text-gray-500">Exporte no ponto 4 para limpar o log.</div>`;
                subStatus.textContent = "FIM DO JOGO. Exportar dados (4) ou carregar novos jogadores (1).";
            } else {
                 logPreview.innerHTML = `<div class="text-indigo-700 font-semibold">Sistema PARADO e REINICIADO.</div><div class="text-sm text-gray-500">O Registo de Dete√ß√£o est√° INATIVO. Clique em "Iniciar Rel√≥gio" (topo) para come√ßar o registo de tempo/estado.</div>`;
                 subStatus.textContent = "Sistema pronto. Selecione 5 jogadores (3) e depois inicie o Rel√≥gio (topo).";
            }
            
            // Garante que o fundo volta a ser preto (estado inicial/parado)
            scoreboardContainer.classList.remove('bg-amber-500');
            scoreboardContainer.classList.add('bg-gray-900');
            subStatus.className = 'status-message bg-indigo-50 border-indigo-500 text-indigo-800';

            renderPlayers();
        }


        // --- FUN√á√ïES DE CONFIGURA√á√ÉO DO PLANTEL ---

        function loadPlayersFromInput() {
            const input = playerInput.value.trim();
            const lines = input.split('\n').filter(line => line.trim() !== '');

            if (lines.length === 0) {
                subStatus.textContent = "ERRO: Introduza os dados dos jogadores (N√∫mero, Nome) no ponto 1.";
                subStatus.className = 'status-message bg-red-50 border-red-500 text-red-800';
                toggleScoreboardBtn.disabled = true; 
                return;
            }

            // Persist√™ncia - Salvar o input no localStorage
            localStorage.setItem('futsal_player_list', input);

            // Limpa o estado atual e carrega novos dados
            playersData = [];
            let errorCount = 0;

            lines.forEach(line => {
                const parts = line.split(',').map(part => part.trim());
                const number = parseInt(parts[0]);
                const name = parts[1];

                if (isNaN(number) || number < 1 || !name) {
                    errorCount++;
                    return;
                }

                // Garante que o jogador est√° em playersData (para manter o estado court)
                const existingPlayer = playersData.find(p => p.number === number);
                if (!existingPlayer) {
                    // Adiciona o novo campo para o total de tempo
                    playersData.push({ number, name, court: false, totalCourtTimeSeconds: 0 });
                } else {
                    existingPlayer.name = name; // Atualiza o nome se o n√∫mero for repetido
                }
            });

            // Parar e resetar o jogo antes de um novo carregamento
            stopAndReset(); 
            logData = []; 
            selectedPlayerOut = null; 
            selectedPlayerIn = null;
            
            // Habilita o placar se houver jogadores
            toggleScoreboardBtn.disabled = playersData.length === 0;

            if (playersData.length > 0) {
                 // Mensagem inicial ajustada para refletir que o log est√° √† espera
                 logPreview.innerHTML = `<div class="text-indigo-700 font-semibold">Sistema iniciado com ${playersData.length} jogadores.</div><div class="text-sm text-gray-500">Selecione 5 jogadores (verde) no ponto 3 e depois clique em "Iniciar Rel√≥gio" (no topo) para come√ßar o registo.</div>`;
            }


            if (playersData.length < 5) {
                 subStatus.textContent = `AVISO: Carregou apenas ${playersData.length} jogadores. Precisa de 5 para as Substitui√ß√µes. Agora, selecione os jogadores.`;
                 subStatus.className = 'status-message bg-yellow-50 border-yellow-500 text-yellow-800';
            } else if (errorCount > 0) {
                subStatus.textContent = `AVISO: ${playersData.length} jogadores carregados. ${errorCount} linha(s) ignorada(s). Selecione os 5 iniciais (3).`;
                subStatus.className = 'status-message bg-yellow-50 border-yellow-500 text-yellow-800';
            } else {
                subStatus.textContent = `SUCESSO: ${playersData.length} jogadores carregados. Agora, selecione os 5 iniciais no ponto 3.`;
                subStatus.className = 'status-message bg-green-50 border-green-500 text-green-800';
            }
            
            // Garantir que todos come√ßam no banco
            playersData.forEach(p => p.court = false);
            renderPlayers(); 
        }

        // --- FUN√á√ïES DE SUBSTITUI√á√ÉO ---

        function renderPlayers() {
            playerContainer.innerHTML = '';
            const courtCount = playersData.filter(p => p.court).length;
            const isInitialSelection = playersData.length > 0 && courtCount < 5;

            playersData.forEach(player => {
                const btn = document.createElement('button');
                btn.className = `player-btn`;
                btn.textContent = `${player.number} - ${player.name}`;
                btn.onclick = () => handlePlayerClick(player.number);
                
                let playerClass = player.court ? 'player-court' : 'player-bench';

                // Verificar sele√ß√£o √öNICA
                const isOut = selectedPlayerOut === player;
                const isIn = selectedPlayerIn === player;

                if (isOut) {
                    playerClass = 'player-out-select';
                } else if (isIn) {
                    playerClass = 'player-in-select';
                }

                btn.classList.add(playerClass);
                playerContainer.appendChild(btn);
            });
            updateSubStatus(courtCount, isInitialSelection);
        }

        function updateSubStatus(courtCount, isInitialSelection) {
            // Contagem e estado √∫nico
            const isReady = selectedPlayerOut !== null && selectedPlayerIn !== null && selectedPlayerOut !== selectedPlayerIn;
            
            confirmSubBtn.disabled = !isReady;
            confirmSubBtn.classList.toggle('opacity-50', !isReady);
            confirmSubBtn.classList.toggle('cursor-not-allowed', !isReady);
            confirmSubBtn.classList.toggle('opacity-100', isReady);
            confirmSubBtn.classList.toggle('cursor-pointer', isReady);
            
            subStatus.classList.remove('bg-red-50', 'bg-yellow-50', 'bg-indigo-50', 'bg-green-50');
            subStatus.classList.remove('border-red-500', 'border-yellow-500', 'border-indigo-500', 'border-green-500');

            if (playersData.length === 0) {
                subStatus.textContent = "Por favor, carregue os jogadores no ponto 1 (Configura√ß√£o do Plantel).";
                subStatus.className = 'status-message bg-indigo-50 border-indigo-500 text-indigo-800';
            }
            else if (isInitialSelection) {
                subStatus.textContent = `Selecione os 5 jogadores iniciais. (Em campo: ${courtCount}/5)`;
                subStatus.className = 'status-message bg-indigo-50 border-indigo-500 text-indigo-800';
                
                if (courtCount === 5) {
                    subStatus.textContent = "5 Iniciais selecionados! O Rel√≥gio pode ser iniciado (topo). Agora, clique no jogador que SAIR (verde) e no que ENTRAR (cinzento).";
                    subStatus.className = 'status-message bg-green-50 border-green-500 text-green-800';
                }
            } else if (selectedPlayerOut || selectedPlayerIn) {
                if (isReady) {
                    subStatus.textContent = `SUBSTITUI√á√ÉO PRONTA: ${selectedPlayerOut.name} (#${selectedPlayerOut.number}) SAIR >> ${selectedPlayerIn.name} (#${selectedPlayerIn.number}) ENTRAR. Clique em CONFIRMAR.`;
                    subStatus.className = 'status-message bg-yellow-50 border-yellow-500 text-yellow-800';
                } else if (selectedPlayerOut && !selectedPlayerIn) {
                    subStatus.textContent = `SELECIONADO: ${selectedPlayerOut.name} (#${selectedPlayerOut.number}) para SAIR. Falta selecionar o jogador para ENTRAR (cinzento).`;
                    subStatus.className = 'status-message bg-red-50 border-red-500 text-red-800';
                } else if (!selectedPlayerOut && selectedPlayerIn) {
                    subStatus.textContent = `SELECIONADO: ${selectedPlayerIn.name} (#${selectedPlayerIn.number}) para ENTRAR. Falta selecionar o jogador para SAIR (verde).`;
                    subStatus.className = 'status-message bg-red-50 border-red-500 text-red-800';
                }
            } else if (courtCount === 5) {
                // Caso a sele√ß√£o inicial j√° esteja feita (courtCount == 5)
                subStatus.textContent = "Clique no jogador EM CAMPO (verde) para iniciar a substitui√ß√£o.";
                subStatus.className = 'status-message bg-indigo-50 border-indigo-500 text-indigo-800';
            }
            
            // Estado adicional para indicar o estado do Placar/Registo
            if (isScoreboardRunning) {
                 subStatus.textContent = `Rel√≥gio ATIVO (${isCountingUp ? 'Crescente' : 'Decrescente'}). Selecione o jogador para SAIR (verde) e para ENTRAR (cinzento).`;
                 subStatus.className = 'status-message bg-indigo-50 border-indigo-500 text-indigo-800';
            } 
        }

        function handlePlayerClick(playerNumber) {
            const player = playersData.find(p => p.number === playerNumber);
            const courtCount = playersData.filter(p => p.court).length;
            const isInitialSelection = playersData.length > 0 && courtCount < 5;

            if (isInitialSelection) {
                // Modo de sele√ß√£o inicial (3. Controlo de Substitui√ß√µes)
                if (player.court) {
                    player.court = false; 
                } else if (courtCount < 5) {
                    player.court = true; 
                }
                renderPlayers();
                return;
            }
            
            // S√≥ permite substitui√ß√µes se houver 5 em campo
            if (courtCount !== 5) return;

            // Modo de substitui√ß√£o √öNICA
            if (player.court) {
                // Jogador EM CAMPO -> Clicado para SAIR (Out)
                if (selectedPlayerOut === player) {
                    selectedPlayerOut = null; // Desselecionar se clicar no mesmo
                } else if (selectedPlayerOut === null) {
                    selectedPlayerOut = player;
                    // Garante que o jogador que sai n√£o est√° selecionado para entrar
                    if (selectedPlayerIn === player) selectedPlayerIn = null;
                } else {
                    // J√° tem um selecionado, substitui-o
                    selectedPlayerOut = player;
                    if (selectedPlayerIn === player) selectedPlayerIn = null;
                }
            } else {
                // Jogador NO BANCO -> Clicado para ENTRAR (In)
                if (selectedPlayerIn === player) {
                    selectedPlayerIn = null; // Desselecionar se clicar no mesmo
                } else if (selectedPlayerIn === null) {
                    selectedPlayerIn = player;
                    // Garante que o jogador que entra n√£o est√° selecionado para sair
                    if (selectedPlayerOut === player) selectedPlayerOut = null;
                } else {
                    // J√° tem um selecionado, substitui-o
                    selectedPlayerIn = player;
                    if (selectedPlayerOut === player) selectedPlayerOut = null;
                }
            }
            renderPlayers();
        }

        function confirmSubstitution() {
            // Substitui√ß√£o √∫nica
            if (!selectedPlayerOut || !selectedPlayerIn || selectedPlayerOut === selectedPlayerIn) {
                console.error("Erro: Substitui√ß√£o incompleta ou inv√°lida.");
                return;
            }
            
            const playerOut = selectedPlayerOut;
            const playerIn = selectedPlayerIn;
            const eventTime = scoreboardDisplay.textContent;
            
            // 1. Atualizar o estado do jogo (playersData)
            playerOut.court = false;
            playerIn.court = true;

            // 2. Criar o registo de evento de substitui√ß√£o
            logData.push({
                type: 'sub', 
                time: eventTime, 
                status: isScoreboardRunning ? 'Andar' : 'Parado', 
                detail: {
                    out_no: playerOut.number,
                    out_name: playerOut.name,
                    in_no: playerIn.number,
                    in_name: playerIn.name
                }
            });
            
            // 3. Atualizar a pr√©-visualiza√ß√£o
            updateLogPreview(
                `SUB: ${playerOut.name} (#${playerOut.number}) >> ${playerIn.name} (#${playerIn.number})`,
                'sub',
                isScoreboardRunning ? 'Andar' : 'Parado'
            );
            
            // 4. Limpar o estado de sele√ß√£o
            selectedPlayerOut = null;
            selectedPlayerIn = null;
            renderPlayers();
        }
        
        // --- FUN√á√ÉO DE C√ÅLCULO DE TEMPO TOTAL EM CAMPO ---
        
        /**
         * Calcula o tempo total em segundos que cada jogador esteve em campo,
         * contando apenas o tempo em que o rel√≥gio estava em estado 'Andar'.
         */
        function calculatePlayerTimeTotals() {
            // Resetar os totais antes de iniciar a contagem
            playersData.forEach(p => p.totalCourtTimeSeconds = 0);
            if (logData.length === 0) return;

            // --- 1. Determinar o estado inicial (Lineup) e o ponto de partida.
            let currentCourtPlayersNumbers = [];
            let loopStartIndex = 0;

            const initialLineupEvent = logData.find(e => e.type === 'initial_lineup');

            if (initialLineupEvent) {
                // Usar a escala√ß√£o registada no momento do in√≠cio do jogo
                currentCourtPlayersNumbers = initialLineupEvent.detail.lineup.map(p => p.num);
                // O loop deve come√ßar no primeiro evento LOGO AP√ìS a defini√ß√£o da escala√ß√£o.
                loopStartIndex = logData.indexOf(initialLineupEvent) + 1; 
            } else {
                // Fallback: usar a escala√ß√£o atual da UI (se o jogo n√£o tiver come√ßado corretamente)
                currentCourtPlayersNumbers = playersData.filter(p => p.court).map(p => p.number);
                console.warn("Nenhum evento de escala√ß√£o inicial encontrado. Usando estado atual da UI para come√ßar.");
            }
            
            // A lista de jogadores √© atualizada no evento logData[i] para o intervalo [i -> i+1].
            
            for (let i = loopStartIndex; i < logData.length - 1; i++) {
                const currentEvent = logData[i];
                const nextEvent = logData[i + 1];

                // --- 1. C√°lculo do Intervalo de Tempo (durante o qual o 'currentEvent.status' era v√°lido) ---
                
                // Ignorar o status event se o log estiver desordenado (tempo igual ou a aumentar no decrescente)
                const currentTimeSeconds = timeToSeconds(currentEvent.time);
                const nextTimeSeconds = timeToSeconds(nextEvent.time);
                
                let intervalSeconds = 0;
                if (isCountingUp) {
                    intervalSeconds = nextTimeSeconds - currentTimeSeconds;
                } else {
                    // Contagem Decrescente: Tempo decorrido √© o valor de tempo que foi consumido.
                    intervalSeconds = currentTimeSeconds - nextTimeSeconds;
                }

                // Apenas processa se o tempo decorreu (intervalo positivo e razo√°vel)
                if (intervalSeconds > 0 && intervalSeconds < 60) {
                    // --- 2. Adicionar Tempo ---
                    // O tempo √© adicionado APENAS se o status do rel√≥gio ERA 'Andar' no momento de currentEvent.
                    if (currentEvent.status === 'Andar') {
                        currentCourtPlayersNumbers.forEach(playerNumber => {
                            const player = playersData.find(p => p.number === playerNumber);
                            if (player) {
                                player.totalCourtTimeSeconds += intervalSeconds;
                            }
                        });
                    }
                }

                // --- 3. Atualizar o Estado do Campo (Substitui√ß√£o) ---
                // Se o evento *currentEvent* for uma substitui√ß√£o, o estado do campo muda para o pr√≥ximo intervalo.
                // A nossa l√≥gica de log j√° regista a substitui√ß√£o no momento exato, e o tempo √© calculado para o intervalo anterior.
                // Aqui, atualizamos a lista de jogadores no campo *para o pr√≥ximo intervalo*.
                if (currentEvent.type === 'sub') {
                    const d = currentEvent.detail;
                    
                    // Player OUT: Remover
                    const outIndex = currentCourtPlayersNumbers.indexOf(d.out_no);
                    if (outIndex > -1) {
                        currentCourtPlayersNumbers.splice(outIndex, 1);
                    }
                    
                    // Player IN: Adicionar
                    if (!currentCourtPlayersNumbers.includes(d.in_no)) {
                        currentCourtPlayersNumbers.push(d.in_no);
                    }
                }
            }
            // O √∫ltimo intervalo (do pen√∫ltimo log at√© ao √∫ltimo log) n√£o √© processado
            // pois n√£o h√° um 'nextEvent' para definir o fim, o que est√° correto.
        }


        // --- FUN√á√ïES DE LOG E EXPORTA√á√ÉO ---

        function updateLogPreview(content, type, status = '') {
            const previewEntry = document.createElement('div');
            
            if (type === 'time') {
                const isStatusChange = (status === 'Parado' || status === 'Andar');
                if (isStatusChange) {
                     previewEntry.className = 'text-primary-red font-semibold py-1 border-b border-red-100';
                     previewEntry.textContent = `[ESTADO ATUALIZADO] ${status.toUpperCase()} em ${content}`;
                } else {
                    // Ignora o log de tempo a cada segundo para manter o hist√≥rico mais limpo,
                    // focando apenas nas mudan√ßas de estado ou substitui√ß√µes.
                    return; 
                }
            } else if (type === 'sub') {
                previewEntry.className = 'p-1 my-1 rounded bg-blue-100 text-blue-800 border-l-2 border-blue-500 font-semibold';
                previewEntry.textContent = `[${status.toUpperCase()}] Substitui√ß√£o: ${content}`;
            } else if (type === 'initial_lineup') {
                 previewEntry.className = 'p-1 my-1 rounded bg-green-100 text-green-800 border-l-2 border-green-500 font-semibold';
                 previewEntry.textContent = `[IN√çCIO] Escala√ß√£o inicial registada em ${content}`;
            }

            logPreview.prepend(previewEntry);
            
            // Limitar o n√∫mero de entradas para manter o log limpo
            while (logPreview.children.length > 15) {
                logPreview.removeChild(logPreview.lastChild);
            }
        }

        /**
         * Exporta os dados registados para um ficheiro CSV.
         */
        function exportData() {
            if (logData.length === 0) {
                subStatus.textContent = "N√£o h√° dados registados para exportar. Inicie o jogo primeiro.";
                subStatus.className = 'status-message bg-red-50 border-red-500 text-red-800';
                return;
            }

    // --- 0. CALCULAR TOTAIS DE TEMPO ---
    calculatePlayerTimeTotals();

// --- 0. CALCULAR TOTAIS DE TEMPO ---
calculatePlayerTimeTotals();

            // Alterado para ponto e v√≠rgula (;) para melhor compatibilidade com Excel em regi√µes como Portugal.
            const delimiter = ';'; 
            // Adiciona o BOM (Byte Ouro Mark) para compatibilidade com caracteres especiais no Excel
            const bom = "\uFEFF"; 
            
            const finalContentArray = [];

            // --------------------------------------------------------
            // SEC√á√ÉO 1: ESCALA√á√ÉO INICIAL
            // --------------------------------------------------------
            finalContentArray.push(" EQUIPA ");
            finalContentArray.push(["N√∫mero", "Nome", "(In√≠cio do Jogo)"].join(delimiter));
            
            const initialLineupEvent = logData.find(e => e.type === 'initial_lineup');
            const initialLineupNumbers = initialLineupEvent ? initialLineupEvent.detail.lineup.map(p => p.num) : playersData.filter(p => p.court).map(p => p.number);
            
            const lineupLines = playersData.map((player) => {
                const isInitial = initialLineupNumbers.includes(player.number);
                
                return [
                    player.number, 
                    player.name, 
                    isInitial ? "Titular" : "Banco"
                ].join(delimiter);
            });
            finalContentArray.push(...lineupLines);
            finalContentArray.push(""); // Linha de separa√ß√£o


            // --------------------------------------------------------
            // SEC√á√ÉO 2: RESUMO DE TEMPO POR JOGADOR (NOVO)
            // --------------------------------------------------------
            finalContentArray.push("TEMPO UTILIZADO");
            finalContentArray.push(["N√∫mero", "Nome", "T.Total (MM:SS)", "T.Total (Seg.)"].join(delimiter));

            // Ordena por tempo total (decrescente)
            const sortedPlayersByTime = playersData.sort((a, b) => b.totalCourtTimeSeconds - a.totalCourtTimeSeconds);

            const timeSummaryLines = sortedPlayersByTime.map(player => {
                const timeStr = formatSecondsToTime(player.totalCourtTimeSeconds);
                return [
                    player.number,
                    player.name,
                    timeStr,
                    player.totalCourtTimeSeconds 
                ].join(delimiter);
            });
            finalContentArray.push(...timeSummaryLines);
            finalContentArray.push(""); // Linha de separa√ß√£o

// --------------------------------------------------------
// SEC√á√ÉO 3: REGISTO DE EVENTOS (LOG) - ORDEM INVERTIDA & H-N LIMPA
// --------------------------------------------------------

let previousClockStatus = null; // Para controlar a repeti√ß√£o do estado

// --------------------------------------------------------
// 1. C√ÅLCULO DA SEC√á√ÉO 3A: Log Completo (7 colunas - A a G)
// --------------------------------------------------------

// Filtra o log para remover a linha de escala√ß√£o inicial (j√° tratada na Sec√ß√£o 1)
const logLines = logData.filter(e => e.type !== 'initial_lineup').map(entry => {
    
    const currentClockStatus = entry.status || 'N/A';
    
    // Colunas 1-7 (Primeiro Grupo)
    let statusCol = "";
    let typeCol = "";
    let outNum = "";
    let outName = "";
    let inNum = "";
    let inName = "";

    // üõë Colunas 8-14 (H-N) N√ÉO S√ÉO MAIS INICIALIZADAS NEM USADAS.
    // -------------------------------------------------------------

    if (entry.type === 'status') {
        // --- L√≥gica de Estado (Andar/Parado) ---
        
        if (currentClockStatus !== previousClockStatus) {
            statusCol = currentClockStatus; // Exibir o novo estado
            previousClockStatus = currentClockStatus; // Guardar o novo estado
        } else {
            statusCol = ""; // Estado igual ao anterior, c√©lula em branco
        }
        
        typeCol = ""; // Tipo de Evento vazio para Status
        
    } else if (entry.type === 'sub') {
        // --- L√≥gica de Substitui√ß√£o: Preenche apenas o Primeiro Grupo (A-G) ---
        const d = entry.detail;
        
        // Reinicia o estado do rel√≥gio
        previousClockStatus = currentClockStatus;
        
        // --- COLUNAS 1-7 (MANTIDAS COMO FORMATO ORIGINAL) ---
        typeCol = "Substitui√ß√£o"; // Tipo de Evento (Coluna C)
        statusCol = ""; // Estado do Rel√≥gio (Coluna B - vazio para Sub)
        
        outNum = d.out_no;
        outName = d.out_name;
        inNum = d.in_no;    
        inName = d.in_name; 
        
    }
    
    // üõë Combina apenas as 7 colunas (A a G) usando o delimitador
    return [
        entry.time, statusCol, typeCol, outNum, outName, inNum, inName
    ].join(delimiter);
    
// üõë Remove linhas vazias (agora s√£o 7 colunas, logo 6 delimitadores)
}).filter(line => line.trim() !== delimiter.repeat(6)); 


// --------------------------------------------------------
// 2. C√ÅLCULO DA SEC√á√ÉO 3B: Log Sequencial (7 colunas - H a N)
// ESTE BLOCO PERMANECE INALTERADO PARA MANTER OS DADOS DE SUBSTITUI√á√ÉO
// --------------------------------------------------------

let lastClockStatus = ""; // Vari√°vel para armazenar o √∫ltimo estado v√°lido (Andar/Parado)

const sequentialLogLines = logData.filter(e => e.type !== 'initial_lineup').map(entry => {
    
    // Atualiza o estado: s√≥ guarda se for um evento de status
    if (entry.status && entry.status !== 'N/A') {
        lastClockStatus = entry.status;
    }

    if (entry.type === 'sub') {
        const d = entry.detail;
        
        // Colunas H a N (7 colunas)
        const xmlTimeCol = entry.time;  
        const xmlStatusCol = lastClockStatus; 
        const xmlTypeCol = "Substitui√ß√£o"; 
        const xmlOutNum = d.out_no; 
        const xmlOutName = d.out_name; 
        const xmlInNum = d.in_no; 
        const xmlInName = d.in_name; 
        
        // Combina as 7 colunas (H a N)
        return [
            xmlTimeCol, xmlStatusCol, xmlTypeCol, xmlOutNum, xmlOutName, xmlInNum, xmlInName
        ].join(delimiter);
    }
    // Retorna nulo ou vazio para eventos que n√£o s√£o 'sub'
    return null;

}).filter(line => line !== null && line.trim() !== delimiter.repeat(6)); 


// --------------------------------------------------------
// 3. ADI√á√ÉO FINAL AO ARRAY (ORDEM INVERTIDA)
// --------------------------------------------------------

// A. SEC√á√ÉO 3B PRIMEIRO (Log Sequencial, 7 colunas)
finalContentArray.push(""); 
finalContentArray.push("REGISTO SUBST."); // T√≠tulo
finalContentArray.push(["Tempo (MM:SS)", "Estado", "Tipo de Evento", "Num Sai", "Nome Sai", "Num Entra", "Nome Entra"].join(delimiter)); // Cabe√ßalho
finalContentArray.push(...sequentialLogLines); // Dados
finalContentArray.push(""); 

// B. SEC√á√ÉO 3A DEPOIS (Log Completo, 7 colunas)
finalContentArray.push("EVENTOS (LOG)"); // T√≠tulo
// üõë ALTERA√á√ÉO AQUI: Cabe√ßalho com apenas 7 t√≠tulos (A-G)
finalContentArray.push(["Tempo (MM:SS)", "Estado do Rel√≥gio", "Tipo de Evento", "Num Sai", "Nome Sai", "Num Entra", "Nome Entra"].join(delimiter)); 

finalContentArray.push(...logLines); // Dados
// Este √© o final da se√ß√£o de log.

// -------------------------------------------------------------------
// Estas linhas criam o conte√∫do do ficheiro real e o URL de download.
// -------------------------------------------------------------------

const fileContent = bom + finalContentArray.join('\n');
¬† ¬† ¬† ¬† ¬† ¬† const blob = new Blob([fileContent], { type: 'text/csv;charset=utf-8;' });
¬† ¬† ¬† ¬† ¬† ¬† const url = URL.createObjectURL(blob);
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† const a = document.createElement('a');
¬† ¬† ¬† ¬† ¬† ¬† a.href = url;
// -------------------------------------------------------------------

        // Criar timestamp com data e hora
const now = new Date();
const timestamp =
    now.getFullYear() + "-" +
    String(now.getMonth() + 1).padStart(2, '0') + "-" +
    String(now.getDate()).padStart(2, '0') + "_" +
    String(now.getHours()).padStart(2, '0') + "-" +
    String(now.getMinutes()).padStart(2, '0');

// Definir nome √∫nico do ficheiro
a.download = `${timestamp}_Volume_de_Jogo.csv`;

¬† ¬† ¬† ¬† ¬† ¬† document.body.appendChild(a);
¬† ¬† ¬† ¬† ¬† ¬† a.click();
¬† ¬† ¬† ¬† ¬† ¬† document.body.removeChild(a);
¬† ¬† ¬† ¬† ¬† ¬† URL.revokeObjectURL(url);
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† // ----------------------------------------------------
            // üí° CORRE√á√ÉO FINAL: Salvar e Restaurar playersData
            // ----------------------------------------------------
            
            // 1. SALVAR O PLANTEL ANTES DO RESET
            // Cria uma c√≥pia profunda (deep copy) da lista atual de jogadores.
            const savedPlayersData = JSON.parse(JSON.stringify(playersData)); 

¬† ¬† ¬† ¬† ¬† ¬† // 5. Limpa o log ap√≥s a exporta√ß√£o e reseta o estado.
¬† ¬† ¬† ¬† ¬† ¬† logData = [];
¬† ¬† ¬† ¬† ¬† ¬† stopAndReset(); // <--- ONDE O playersData PODE SER APAGADO

            // 2. RESTAURAR O PLANTEL (Sobrescreve qualquer limpeza feita pelo stopAndReset)
            playersData = savedPlayersData; 
            
            // 3. Redesenhar os bot√µes (agora a lista playersData n√£o est√° vazia)
¬† ¬† ¬† ¬† ¬† ¬† renderPlayers(); 
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† // Mensagem de sucesso
            subStatus.textContent =
¬† ¬† `Dados exportados com sucesso!, Ficheiro criado:, ${timestamp}_Volume_de_Jogo.csv`;
subStatus.className = 'status-message bg-green-50 border-green-500 text-green-800';
¬† ¬† ¬† ¬† ¬† ¬† subStatus.className = 'status-message bg-green-50 border-green-500 text-green-800';
¬† ¬† ¬† ¬† } // Fecho final da fun√ß√£o (se aplic√°vel)

        // --- INICIALIZA√á√ÉO ---
document.addEventListener('DOMContentLoaded', () => {
    // Aplica o preset inicial
    applyPreset(); 
    
    // Verifica se existe plantel guardado
    const savedList = localStorage.getItem('futsal_player_list');

    if (savedList) {
        // Preenche o textarea
        playerInput.value = savedList;

        // Carrega os jogadores SEM resetar o sistema
        const lines = savedList.split('\n').filter(line => line.trim() !== '');

        playersData = lines.map(line => {
            const [num, name] = line.split(',').map(v => v.trim());
            return {
                number: parseInt(num),
                name: name,
                court: false,
                totalCourtTimeSeconds: 0
            };
        });

        // Renderiza os jogadores no ecr√£
        renderPlayers();

        // Atualiza mensagens
        subStatus.textContent = "Plantel carregado automaticamente da √∫ltima sess√£o. Selecione os 5 iniciais.";
        subStatus.className = 'status-message bg-green-50 border-green-500 text-green-800';

        logPreview.innerHTML = `<div class="text-indigo-700 font-semibold">Plantel restaurado (${playersData.length} jogadores).</div><div class="text-sm text-gray-500">Selecione os 5 iniciais antes de iniciar o rel√≥gio.</div>`;
        
        // Ativa o bot√£o do rel√≥gio
        toggleScoreboardBtn.disabled = false;

    } else {
        // N√£o existe plantel guardado, usar o default do textarea
        loadPlayersFromInput();
    }
    
    // Listeners para atualizar tempo
    timePresetSelect.addEventListener('change', applyPreset); 
    initialMinutesInput.addEventListener('change', updateTimeConfiguration);
    initialSecondsInput.addEventListener('change', updateTimeConfiguration);
    timeDirectionSelect.addEventListener('change', updateTimeConfiguration);
        });

    </script>
</body>
</html>
